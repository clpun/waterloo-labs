/*************************************************
 * ExpressionTester
 * A class for testing singly-linked lists.
 *
 * Author:  Douglas Wilhelm Harder
 * Copyright (c) 2006 by Douglas Wilhelm Harder.  All rights reserved.
 *
 * DO NOT EDIT THIS FILE
 *************************************************/

#ifndef EXPRESSION_TESTER_H
#define EXPRESSION_TESTER_H

#include "Exception.h"
#include "Tester.h"
#include "Expression.h"

#include <iostream>

using namespace std;


class ExpressionTester:public Tester<Expression> {
	public:
		ExpressionTester( Expression *obj = 0 ):Tester<Expression>( obj ) {
			// empty
		}
		void process();
};

/****************************************************
 * void process()
 *
 * Process the current command.  For singly-linked lists, these include:
 *
 *  Accessors
 *
 *   evaluate        evaluate        evaluate the expression
 *   evaluate!       evaluate        evaluate the expression catching a division-by-zero error
 *   in_fix          in_fix          print the tree using in-fix notation
 *   reverse_polish  reverse_polish  print the tree using reverse-polish notation
 *
 *  Mutators
 *
 *   add n             add               add expr + n (always succeeds)
 *   subtract n        subtract          subtract expr - n (always succeeds)
 *   subtracted_from n subtracted_from   subtract n - expr (always succeeds)
 *   times n           times             multiply expr *n (always succeeds)
 *   divided_by n      divided_by        divide expr / n (always succeeds)
 *   divides n         divides           divide n / expr (always succeeds)
 *
 *   details                             print the memory details
 ****************************************************/





void ExpressionTester::process() {
	if ( command == "evaluate" ) {
		// check if the evaluated value equals the next integer read

		int expected_value;

		cin >> expected_value;

		int actual_value = object->evaluate();

		if ( actual_value == expected_value ) {
			cout << "Okay" << endl;
		} else {
			cout << "Failure in evaluate(): expecting the value '" << expected_value << "' but got '" << actual_value << "'" << endl;
		}
	} else if ( command == "evaluate!" ) {
		// evaluate a division-by-zero

		int actual_value;

		try {
			actual_value = object->evaluate();
			cout << "Failure in evaluate(): expecting to catch an exception but got '" << actual_value << "'" << endl;
		} catch( division_by_zero ) {
			cout << "Okay" << endl;
		} catch (...) {
			cout << "Failure in evaluate(): expecting an division_by_zero exception but caught a different exception" << endl;
		}
	} else if ( command == "reverse_polish" ) {
		object->reverse_polish();
	} else if ( command == "in_fix" ) {
		object->in_fix();
	} else if ( command == "add" ) {
		// add the next integer read to the expression (always succeeds)

		int n;

		cin >> n;

		object->add( n );
		cout << "Okay" << endl;
	} else if ( command == "subtract" ) {
		// subtract the next integer read from the expression (always succeeds)

		int n;

		cin >> n;

		object->subtract( n );
		cout << "Okay" << endl;
	} else if ( command == "subtracted_from" ) {
		// subtract the expression from the next integer read (always succeeds)

		int n;

		cin >> n;

		object->subtracted_from( n );
		cout << "Okay" << endl;
	} else if ( command == "times" ) {
		// multiply the next integer read to the expression (always succeeds)

		int n;

		cin >> n;

		object->times( n );
		cout << "Okay" << endl;
	} else if ( command == "divided_by" ) {
		// divide the expression by the next integer read (always succeeds)

		int n;

		cin >> n;

		object->divided_by( n );
		cout << "Okay" << endl;
	} else if ( command == "divides" ) {
		// divide the next integer read by the expression (always succeeds)

		int n;

		cin >> n;

		object->divides( n );
		cout << "Okay" << endl;
	} else {
		cout << command << ": Command not found." << endl;
	}
}
#endif
